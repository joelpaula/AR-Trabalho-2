---
title: "Análise de Redes - Trabalho de Grupo n.º 2"
author:
- Catarina Castanheira, 92478
- João Martins, 93259
- Joel Paula, 93392
date: "03/01/2022"
output:
  html_document: 
    keep_md: yes
    fig_width: 16
    fig_height: 9
  pdf_document: 
    fig_width: 16
    fig_height: 9
  word_document: 
    fig_width: 16
    fig_height: 9
subtitle: 'Ciência de Dados - PL - 3º ano | Professora: Maria João Frazão Lopes'
header-includes:
- \usepackage[sfdefault]{roboto}
- \renewcommand{\familydefault}{\sfdefault}
- \usepackage{titling}
- \pretitle{\par\vspace{50mm}\begin{center}
- \posttitle{\par\vspace{100mm}\end{center}} \includegraphics[width=2in,height=2in]{rgb_iscte_pt_horizontal_positive.png}\LARGE\\}
- \usepackage{caption}
- \captionsetup[table]{labelformat=empty}
- \captionsetup[figure]{labelformat=empty}
editor_options:
  markdown:
    wrap: 90
---

```{css, echo=FALSE}
#header {
  background-image: url("rgb_iscte_pt_horizontal_positive.png");
  background-size: 300px;
  background-repeat: no-repeat;
  background-position: 0px 0px;
  padding-top: 95px;
}
#header > * {
  max-width: calc(100% - 225px);
}
#header > *
  max-width: 100%;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(igraph)
```

# QUESTÃO 1:

> Suponha que pretende gerar uma rede aleatória não orientada com 100 nodos e grau médio aproximadamente igual a 4. Qual deve ser a probabilidade utilizada na geração da rede?
> Gere esta rede.

O grau médio seria de aproximadamente 100, se todos os nodos estivessem ligados entre si. Neste caso teremos uma probabilidade de 4% - que cada nodo esteja ligado apenas a 4 dos 100 nodos.

É possível determinar o grau médio de uma rede conhecendo o número de nodos e a probabilidade de geração utilizada:

$\langle k\rangle = p(N-1)$

Isto significa que, resolvendo a equação em função de p, temos:

$p = \langle k\rangle / (N-1)$

No nosso caso concreto, o objectivo é obtermos $\langle k\rangle = 4$, tendo $N=100$. Logo, a probabilidade que deverá ser usada na geração da rede aleatória é:

$p = 4/(100-1) \Leftrightarrow p = 4/99 = 0.04 \text{ (aprox.)}$

Ou seja, para obtermos uma rede aletória de 100 nodos e um grau médio de 4, deveremos usar uma probabilidade de 4% na geração das suas ligações.

```{r}
set.seed(42)
graph1 <- sample_gnp(100, 0.04)
degrees <- degree(graph1, mode="all")
par(mar=c(0,0,1,0))
# Gráfico com grau
plot(graph1,  vertex.size=3+degrees*2, edge.color="orange4"
     , edge.width=2
     , vertex.label=degrees
     , vertex.label.cex=0.75
     , vertex.label.color="black"
     , vertex.label.family="sans"
     , vertex.frame.color="orange"
     , vertex.color = "orange"
     , main="Rede aleatória representando os graus dos nodos"
     )
```

> Caracterize esta rede quanto ao grau médio dos nodos, à conectividade, distância média e existência de triângulos. Aplique ainda métodos de identificação de comunidades.

## Grau Médio

```{r}
# grau médio
mean(degree(graph1))
```

O grau médio é próximo de 4, tal como esperaríamos.

## Conectividade

```{r}
degree(graph1)
```

Vemos que existem 4 nodos com grau zero, o que indica que não têm qualquer ligação. Neste caso estamos perante uma rede desconexa.

Portanto, existem 4 nodos isolados e uma componente gigante.

```{r}
components(graph1)
```

## Associação

```{r}
# Associação de grau
assortativity_degree(graph1) 
```

É negativo mas muito próximo de zero, por isso não é um rede associativa mas também não se pode concluir que é Não associativa.

Vamos olhar agora para o método de medição da associação de grau com base no grau médio dos nodos adjacentes:

```{r}
knn(graph1)$knnk

```

A função tem uma tendência decrescente, mas não estritamente decrescente, oscilando. Por isso mantemos que não é uma rede associativa mas também não pode ser classificada como não associativa.

## Distância média

```{r}
# distância média
mean_distance(graph1)

log10(100)

#diâmetro
diameter(graph1)
```

A distância média é grande, já que se afasta substancialmente de $log10(N)$.

A maior distância entre nodos (conectados) é de 8.

## Existência de triângulos

```{r}
# Coeficiente de clustering
transitivity(graph1, type="global")
```

É um número baixo de triângulos, já que o coeficiente de *clustering* é um rácio entre o número de triângulos e o número total de ternos conexos e este é baixo.

## Identificação de comunidades

Usando o método do corte mínimo:

```{r}
min_cut(graph1, value.only = F)
```

Temos um conjunto com os nodos ligados (a componente gigante) e um outro com os nodos isolados. Com um corte de dimensão zero.

Usando o método das cliques:

```{r}
sapply(cliques(graph1),length)

```

As cliques parecem fazer divisões muito pequenas, de 1, 2 ou 3 nodos. Sendo que as maiores cliques têm 3 nodos. O número excessivo de comunidades é um dos problemas conhecidos deste algoritmo.

```{r}
largest_cliques(graph1)
```

Função que mostra dados sobre *clusters*:
```{r}
show.cluster <- function(g1, cl) {
  plot(cl, g1
          , edge.color="orange4"
          , edge.width=2
          , vertex.label.cex=0.75
          , vertex.label.color="black"
          , vertex.label.family="sans"
          , vertex.frame.color="orange4"
          )
  print(c("Número de clusters:", length(cl)))
  print("Tamanho dos clusters:")
  print(sizes(cl))
  print(c("modularidade:", modularity(cl)))
  print("Pertença a clusters:")
  membership(cl)
}
```

Verificando o método de clustering pela remoção de pontes:

```{r}
show.cluster(graph1, cluster_edge_betweenness(graph1))
```

Usando o método de clustering pela propagação de etiquetas:

```{r}
set.seed(42)
show.cluster(graph1, cluster_label_prop(graph1))
```

Usámos o `set.seed(42)` para estabilizar numa mesma solução, para análise.

Usando o método da otimização de modularidade:

```{r}
show.cluster(graph1, cluster_fast_greedy(graph1))
```

# QUESTÃO 2:

> Utilize o programa seguinte para gerar a rede aleatória rn2:

```{r}
set.seed(42)
rn2 <- graph(edge=c(1,2,1,3,2,3,3,4,3,5,4,5,5,6,5,7,6,7,7,8,7,9,8,9,2,4,4,6,6,8)
             ,n=100
             ,directed=F);
x = 9;
y = 15;
for (i in 1:91) {
  new <- floor(runif(1,min=1,max=x));
  nn <- neighbors(rn2,new);
  x = x+1;
  y = y+1;
  rn2 <- add_edges(rn2,c(new,x));
  newr <- runif(1);
  y = y+1;
  if (newr < 0.75) {
    new1 <- floor(runif(1,min=1,max=degree(rn2,new,mode="all")));
    rn2 <- add_edges(rn2,c(x,nn[new1]))}
  else {
    new2 <- new; 
    while (new==new2) new2<-floor(runif(1,min=1,max=x-1));
    rn2 <- add_edges(rn2,c(new2,x))};
}
```

> Qual o método utilizado nesta geração? Justifique.

O método utilizado nesta geração é o Modelo do Passeio Aleatório. Neste método, começamos a criação de uma rede aleatória a partir de uma pequena sub-rede - no programa temos uma subrede conexa composta por 9 nodos, com a representação abaixo:

```{r}
set.seed(42)
plot(graph(edge=c(1,2,1,3,2,3,3,4,3,5,4,5,5,6,5,7,6,7,7,8,7,9,8,9,2,4,4,6,6,8),directed=F)
     , edge.color="orange4"
     , edge.width=2
     , vertex.label.color="black"
     , vertex.label.family="sans"
     , vertex.frame.color="orange"
     , vertex.color = "orange"
     , main="Sub-rede conectada, de partida")
```

Na prática, a rede gerada pelo programa contém já os 100 nodos que se pretende utilizar, mas os restantes 91 não têm, na fase inicial, ainda qualquer ligação. Com a construção da rede aleatória eles serão iterativamente adicionados. Em cada iteração, ou seja, por cada um dos 91 nodos que serão adicionados à subrede conexa já existente, temos:

-   o método selecciona aleatoriamente a partir de uma distribuição uniforme um dos nodos da subrede ("new"), e identifica quais os respectivos nodos adjacentes. Cria entretanto uma ligação entre o nodo seleccionado e o próximo a ser integrado na sub-rede (ou seja, um nodo do subconjunto que têm grau zero; na primeira iteração, por exemplo, cria uma nova ligação entre o nodo 10 e um dos da subrede conexa);

-   é gerado um número aleatório que dita uma probabilidade (p = 0.75 e q = 0.25), que é usada da seguinte forma:

    -   se obtivermos p (com probabilidade de 75%), então é criada mais uma ligação entre o novo nodo e um dos adjacentes de "new" (já identificado no início da iteração) - criando um triângulo;

    -   se obtivermos q (1-p), então é criada mais uma ligação entre o novo nodo e um dos já pertencentes à subrede conexa, seleccionado aleatoriamente a partir de uma distribuição uniforme;

Este método termina quando todos os 91 nodos tiverem sido adicionados à rede através da criação das ligações.

Este é um método de geração de redes aleatórias que não escolhe os nodos adjacentes com base no seu grau. Esta escolha é aleatória.

> Caracterize esta rede quanto ao grau médio dos nodos, à conectividade, distância média e existência de triângulos. Aplique ainda métodos de identificação de comunidades.

```{r}
set.seed(42)
degrees <- degree(rn2, mode="all")
par(mar=c(0,0,1,0))
# Gráfico com grau
plot(rn2,  vertex.size=degrees*2, edge.color="orange4"
     , edge.width=2
     , vertex.label=degrees
     , vertex.label.cex=0.75
     , vertex.label.color="black"
     , vertex.label.family="sans"
     , vertex.frame.color="orange"
     , vertex.color = "orange"
     , main="Rede aleatória 2 representando os graus dos nodos"
     )
```

```{r}
# Grau médio
mean(degree(rn2))
```

O grau médio é próximo de 4, em semelhança à primeira rede.

```{r}
# Conectividade
degree(rn2)
```

Não existem nodos com grau igual a 0, o que quer dizer que existe um caminho entre qualquer par de nodos. Neste caso estamos perante uma rede conexa.

```{r}
# Associação de grau
assortativity_degree(rn2) 
```

É muito próximo de zero, por isso não é um rede associativa mas também não se pode concluir que é Não associativa.

```{r}
knn(rn2)$knnk
```

```{r}
# Distância média
mean_distance(rn2)
```

```{r}
log10(100)
```

A distância média é grande, já que se afasta substancialmente de $log10(N)$.

```{r}
# Diâmetro
diameter(rn2)
```

A maior distância entre nodos (conectados) é de 7.

```{r}
# Existência de triângulos
transitivity(rn2, type = "global")
```

O rácio é bastante superior a zero, embora não se aproxime de 1 - revela a existência de bastantes triângulos.

## Identificação de comunidades

Usando o método do corte mínimo:

```{r}
set.seed(42)
min_cut(rn2, value.only = F)
```

Mais uma vez, este método separa a rede em dois com dimensão dois - uma componente gigante e um nodo isolado.

Usando o método das cliques:

```{r}
sapply(cliques(rn2),length)

```

As cliques parecem fazer divisões muito pequenas, de 1, 2 ou 3 nodos. Sendo que as maiores cliques têm 3 nodos. O número excessivo de comunidades é um problema conhecido deste algoritmo.

```{r}
largest_cliques(rn2)
```

Verificando o método da remoção de pontes:

```{r}
show.cluster(rn2, cluster_edge_betweenness(rn2))
```

Usando o método de propagação de etiquetas:

```{r}
set.seed(42)
show.cluster(rn2, cluster_label_prop(rn2))
```

Usámos o `set.seed(42)` para estabilizar numa mesma solução, para análise.

Usando o método da otimização de modularidade:

```{r}
show.cluster(rn2, cluster_fast_greedy(rn2))
```

# QUESTÃO 3:

> Compare e comente os resultados obtidos nas questões anteriores.

Que diferenças conseguimos observar entre a questão 1 e a 2? O que é que dá para concluir?

-   CC sobre a associação de grau

-   CC sobre a distância média

-   CC sobre o diâmetro

-   CC sobre a existência de triângulos

-   JP sobre as comunidades

-   JM o impacto que o método *random walk* tem na construção de uma rede aleatória; vantagens e desvantagens dos métodos usados em 1 e 2
